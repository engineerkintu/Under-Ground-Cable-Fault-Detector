/* Main.c file generated by New Project wizard
 *
 * Created:   Mon Apr 25 2016
 * Processor: 80C51
 * Compiler:  Keil for 8051
 */

#include <reg51.h>
#include <stdio.h>


 
//Constants
#define E_Delay       250       
 
//Function Declarations    for LCD
void delay_sec(unsigned int);
void __delay_us(unsigned int);    
void InitLCD(void);
void WriteCommandToLCD(int);
void WriteDataToLCD(char);
void WriteStringToLCD(const char*);
void ClearLCDScreen(void);
 
// Function Declarations for ADC
void InitADC(void);
unsigned char ReadADC(unsigned char);
void Display(unsigned char);

// Define ADC0808 Channels
#define AN0        0
#define AN1        1
#define AN2        2
#define AN3        3
#define AN4        4
#define AN5        5
#define AN6        6
#define AN7        7
 
// Define Pins
sbit Add_A = P2^0;     // Address Pin A
sbit Add_B = P2^1;     // Address Pin B
sbit Add_C = P2^2;     // Address Pin C
sbit ALE   = P2^3;     // Address Latch Enable
sbit EOC   = P2^4;     // End Of Conversion
sbit OE    = P2^5;     // Output Enable
sbit START = P2^6;     // Start Conversion
sbit CLK   = P2^7;     // Clock for AD0808

//Defines Pins
sbit RS = P3^6;
sbit E  = P1^0;

// Define Data Bus
#define Data_Bus     P0
#define HalfCycleDelay        10        // usecs

sbit RELAY1 = P1^2;
sbit RELAY2 = P1^3;
sbit RELAY3 = P1^1;

//unsigned char Buff[3] = 0;

void main(void)
 { 
   
	unsigned char ADC_Value = 0;         // To capture ADC value
    unsigned char Digit[3] = { 0,0,0 };    // To make digits to display on LCD
	
	
 
    InitADC();                            // Initialize ADC
    InitLCD();                            // Initialize LCD display
    WriteStringToLCD("Starting...");    // Show Welcome Message
    delay_sec(1);                        // 1 Sec delay
	ClearLCDScreen();
	WriteStringToLCD("***Welcome***");
	delay_sec(2);
	ClearLCDScreen();
	WriteStringToLCD("Fault Locator 1");
	delay_sec(2);
    ClearLCDScreen();
   while(1)
   { 
	   RELAY1 = 1;
	   delay_sec(1);
	    ADC_Value = ReadADC(AN1);        // Read ADC value from Channel 
	   	WriteStringToLCD("R: ");                // Display string
	    Display(ADC_Value);
        delay_sec(2);
	    ClearLCDScreen();
	    RELAY1 = 0;
	   
	   RELAY2 = 1;
	   delay_sec(1);
	   WriteStringToLCD("B: ");
	    ADC_Value = ReadADC(AN1);
	   Display(ADC_Value);
	   delay_sec(2);
	   ClearLCDScreen();
	   RELAY2 = 0;
	   
	   RELAY3 = 1;
	   delay_sec(1);
	   WriteStringToLCD("Y: ");
	   ADC_Value = ReadADC(AN1);
	   Display(ADC_Value);
	   delay_sec(2);
	   ClearLCDScreen();
	   RELAY3 = 0;
	   
	  
   } 
  
      
 }
 //////////////////End of Main Function //////////////////
 
//Function for Initialization of ADC0
void InitADC(void)
    {
        Add_A = 0;          // Make output
        Add_B = 0;          // Make output 
        Add_C = 0;          // Make output
        ALE   = 0;          // Make output
        EOC   = 1;          // Make input
        OE    = 0;          // Make output
        START = 0;          // Make output
        CLK   = 0;          // Make output
        Data_Bus = 0xFF;    // Make Inputs    
    }
 
unsigned char ReadADC(unsigned char Channel)
    {
        unsigned int i = 0;
        unsigned int ADC_value = 0;
 
        /*Selecting analog Channel by providing respective 
        bits to A,B,C addresses*/
        switch(Channel)
        {
        case AN0: Add_C = 0;  Add_B = 0;  Add_A = 0; break;
        case AN1: Add_C = 0;  Add_B = 0;  Add_A = 1; break;
        case AN2: Add_C = 0;  Add_B = 1;  Add_A = 0; break;
        case AN3: Add_C = 0;  Add_B = 1;  Add_A = 1; break;
        case AN4: Add_C = 1;  Add_B = 0;  Add_A = 0; break;
        case AN5: Add_C = 1;  Add_B = 0;  Add_A = 1; break;
        case AN6: Add_C = 1;  Add_B = 1;  Add_A = 0; break;
        case AN7: Add_C = 1;  Add_B = 1;  Add_A = 1; break;
        }       
 
        __delay_us(HalfCycleDelay);        // 250kHz Frequency
        ALE = 1;                // Enable Address Latch
        CLK = 1;                 // Make CLK High
        __delay_us(HalfCycleDelay);        // 250kHz Frequency
        CLK = 0;                 
        START = 1;                // Start ADC Conversion
        __delay_us(HalfCycleDelay);        // 250kHz Frequency
        CLK = 1;                 // Make CLK High
        ALE = 0;                // Disable Address Latch
        __delay_us(HalfCycleDelay);        // 250kHz Frequency
        CLK = 0;                 // Make CLK Low
        START = 0;                // Complete the start pulse
 
        for(i=0;i<2000;i++)
        {
            CLK = !CLK;            // Toggle Clock
            __delay_us(HalfCycleDelay);    // 250kHz Frequency
            if(!EOC)              // Wait for EOC to be low
            break;
        }
 
        for(i=0;i<2000;i++)
        {
            CLK = !CLK;            // Toggle Clock
            __delay_us(HalfCycleDelay);    // 250kHz Frequency
             if(EOC)                // Wait for EOC to be High    
            break;
        }
 
        CLK = 0;                 // Make CLK Low
        OE = 1;                    // Enable Output
        __delay_us(HalfCycleDelay);        // 250kHz Frequency
        CLK = 1;                 // Make CLK High
        __delay_us(HalfCycleDelay);        // 250kHz Frequency
        CLK = 0;                 // Make CLK Low
        __delay_us(HalfCycleDelay);        // 250kHz Frequency
        CLK = 1;                 // Make CLK High
        ADC_value = Data_Bus;            // Read value
        __delay_us(HalfCycleDelay);        // 250kHz Frequency
        OE = 0;                    // Disable Output
        CLK = 0;                 // Make CLK Low
        __delay_us(HalfCycleDelay);        // 250kHz Frequency
        return ADC_value;                // Return ADC value
    }
 
// Function for approximate delay in Secs.
void delay_sec(unsigned int d)
    {
   unsigned int i;
   for(i=0;i<(d*20);i++)
           __delay_us(50000);
    }
 
// Function for approximate delay in given uSecs.
void __delay_us(unsigned int d)
    {
   unsigned int i, limit;
   limit = d/15;
   for(i=0;i<limit;i++);
    }
 
void ToggleEpinOfLCD(void)
    {
    E = 1;                // Give a pulse on E pin
    __delay_us(E_Delay);  // so that LCD can latch the
    E = 0;                // data from data bus
    __delay_us(E_Delay);     
    }
 
//Function for Writing Data to LCD 
void WriteDataToLCD(char t)
    {
   RS = 1;             // This is data
 
   P1 &= 0x0F;           // Make P1.4 to P1.7 zero
   P1 |= (t&0xF0);     // Write Upper nibble of data
   ToggleEpinOfLCD();  // Toggle E pin to send data 
 
   P1 &= 0x0F;           // Make P1.4 to P1.7 zero
   P1 |= ((t<<4)&0xF0);// Write Lower nibble of data
   ToggleEpinOfLCD();  // Toggle E pin to send data 
    }
 
//Function for Writing COmmand to LCD
void WriteCommandToLCD(int z)
    {
   RS = 0;             // This is command
 
   P1 &= 0x0F;           // Make P1.4 to P1.7 zero
   P1 |= (z&0xF0);     // Write Upper nibble of data
   ToggleEpinOfLCD();  // Toggle E pin to send data 
 
   P1 &= 0x0F;           // Make P1.4 to P1.7 zero
   P1 |= ((z<<4)&0xF0);// Write Lower nibble of data
   ToggleEpinOfLCD();  // Toggle E pin to send data 
		
	
    }
 
//Writing Function for Initializaing of LCD 
void InitLCD(void)
    {
    RS = 0;             // Make pin zero
    E  = 0;            // Make Pin zero                    
 
  ///////////// Reset process from datasheet /////////
     __delay_us(15000);
	
	
	
 
     P1 &= 0x0F;           // Make P1.4 to P1.7 zero
     P1 |= 0x30;           // Write 0x3
     ToggleEpinOfLCD();    // Toggle E pin to send data 
 
     __delay_us(4500);
 
     P1 &= 0x0F;           // Make P1.4 to P1.7 zero
     P1 |= 0x30;           // Write 0x3
     ToggleEpinOfLCD();    // Toggle E pin to send data 
 
     __delay_us(300);
 
     P1 &= 0x0F;           // Make P1.4 to P1.7 zero
     P1 |= 0x30;           // Write 0x3
     ToggleEpinOfLCD();    // Toggle E pin to send data 
 
     __delay_us(650);
 
     P1 &= 0x0F;           // Make P1.4 to P1.7 zero
     P1 |= 0x20;           // Write 0x2
     ToggleEpinOfLCD();    // Toggle E pin to send data 
 
     __delay_us(650);
 
   WriteCommandToLCD(0x28);    //function set
   
   WriteCommandToLCD(0x0c);    //display on,cursor off,blink off
   WriteCommandToLCD(0x01);    //clear display
   WriteCommandToLCD(0x06);    //entry mode, set increment
}
 
//Function for Writing String to LCD
void WriteStringToLCD(const char *s)  
{
    while(*s)
        WriteDataToLCD(*s++);   // print first character on LCD 
}
 
// Writing Function for Clear the LCD Screen and return cursor to zero position
void ClearLCDScreen(void)       
{
    WriteCommandToLCD(0x01);    // Clear the screen
    __delay_us(2000);           // Delay for cursor to return at zero position
}

void Display(unsigned char Data)
{
   switch(Data)
   {
      case 170:
         WriteStringToLCD("1KM");
      break;
      
      case 204:
          WriteStringToLCD("2KM");
         break;
         
      case 219:
          WriteStringToLCD("3KM");
         break;
         
      case 227:
          WriteStringToLCD("4KM");
         break;
         
      case 255:
          WriteStringToLCD("NF");
         break;
         
      default:
         break;
   }
 }